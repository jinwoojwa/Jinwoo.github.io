---
title: "[컴파일러] Top-down 파싱 & LL 파싱"
excerpt: "FIRST, FOLLOW, LL 조건, LL 문법"

categories:
  - 컴파일러
tags:
  - [컴파일러]

permalink: /compiler/compiler_topdown/

toc: true
toc_sticky: true
use_math: true

date: 2024-10-16
last_modified_at: 2024-10-16
---

# 👑 Top-down 파싱

구문 분석의 한 유형인 **Top-down** 파싱은 시작 심벌로부터 터미널 노드쪽으로 파스트리를 <br>

구성하는 것으로 입력 문자열에 대한 좌측 유도 과정이다. 유도 과정에서 생성 문자열과 입력 문자열을 <br>

비교하며, 생성 규칙을 적용해 나가는 방식이며, **백트래킹** 기법이 사용된다.

<center><img src="https://github.com/user-attachments/assets/51f597b2-4807-4a4a-8b76-13a2279fc8e1" width=500></center>

<br><br>

# 👑 LL 파싱

LL 파싱은 컴파일러에서 사용하는 Top-down 파싱 기법 중 하나로, 입력 문자열을 왼쪽에서 <br>

오른쪽으로 한 글자씩 분석하고, 좌파스(Leftmost derivation)를 생성하는 방법이다. LL 파싱은 <br>

**LL(k)**로 표현되며, 여기서 L은 `Left-to-right(입력의 왼쪽에서 오른쪽으로 분석)`, 두 번째 L은 <br>

`Leftmost derivation(좌파스 유도)`을 의미하고, `k`는 파서가 한 번에 미리 읽어야 할 입력 <br>

심볼의 수를 나타낸다. <br><br>

LL 파싱은 입력 문자에 따라 생성 규칙이 **결정적으로** 선택되므로, 백트래킹이 필요하지 않다. <br>

하지만, 이를 위해 입력 문자마다 적용될 생성 규칙을 미리 알고 있는 상태에서 시작해야 하며, <br>

이를 위해 **FIRST 집합**, **FOLLOW 집합** 등이 사용된다.

<br><br>

## 💡 FIRST 집합

**FIRST**는 nonterminal로 부터 유도되어 첫 번째로 나타날 수 있는 terminal의 집합이다. <br>

예를 들어, 아래와 같은 생성 규칙이 존재한다고 했을 때, 생성 규칙의 각 nonterminal의 <br>

FIRST 집합을 구할 수 있다.

<center><img src="https://github.com/user-attachments/assets/c5bdd758-679a-47e4-b090-090a5928f9dd" width=500></center>

<br>

**FIRST 구하는 방법**

- X가 terminal이면 FIRST(X)는 자기 자신이다.

    + $ FIRST(e) = \lbrace e \rbrace $

<br>

- **X → aα** 형태의 생성규칙이 존재하면, a는 FIRST(X)에 포함된다.

    + `S → aXb` 를 통해 $ FIRST(S) = \lbrace a \rbrace $ 가 포함된다.

<br>

- **X → ε** 의 형태 즉, X가 **nullable**하다면, ε는 FIRST(X)에 포함된다.

    + `A → a | ε` 라면, $ FIRST(A) = \lbrace a, ε \rbrace $

<br>

- $ X → Y_1 Y_2 ...Y_k $ 인 생성규칙이 존재할 때, $ FIRST(X) = FIRST(X) ∪ FIRST(Y_1 Y_2 ...Y_k) $

    + $ FIRST(Y_1 Y_2 ...Y_n) = FIRST(Y_1) ⨁ FIRST(Y_2) ⨁ ... ⨁ FIRST(Y_n) $

>  ⨁ (Ring Sum) : 두 집합 간의 연산에 사용되는 ⨁ 는 다음과 같이 정의할 수 있다. <br><br>
   if ε ∉ A then A ⨁ B = A <br>
   if ε ∈ A then A ⨁ B = (A - {ε}) ∪ B <br><br>
   A의 nullable 여부에 따라 계산 결과가 정해진다.

<br>

**FIRST 예시**

<center><img src="https://github.com/user-attachments/assets/9a1a24fc-ca53-458c-9008-c77075e89591" width="500"></center>

<br><br>

## 💡 FOLLOW 집합

nonterminal이 **ε-생성 규칙**을 갖는 경우 FIRST만으로는 생성규칙을 결정적으로 선택할 수 <br>

없다. 따라서, nonterminal의 다음에 나오는 심벌에 따라 어느 생성 규칙으로 유도할 것인가를 <br>

결정하는 것이 필요하다. <br><br>

**FOLLOW(X)**란 시작 심벌로부터 유도될 수 있는 모든 문장 형태에서 X 다음에 나오는 <br>

terminal 심벌들의 집합이다. FOLLOW 집합을 구할 때 기호 `$`가 사용되는데, 이것은 입력 문자열의 <br>

끝을 나타내는 기호이다. 시작 심벌은 초기값으로 `$`를 가져야 한다.

<center><img src="https://github.com/user-attachments/assets/62c11fc6-298d-4654-8ced-928fb5f4e2f5" width=500></center>

<br>

**FOLLOW 구하는 방법**

- 시작 심벌은 초기값으로 `$`를 갖는다.

    + **FOLLOW(S) = {$}**

<br>

- $ A →αBβ, β ≠ ε $ 의 형태일 때

    + $ FOLLOW(B) = FOLLOW(B) ∪ (FIRST(β) - \lbrace ε \rbrace) $

<br>

- $ A → αB $ 또는 $ A → αBβ $ 에서 FIRST(β)에 ε이 속하는 경우 (β가 nullable한 경우)

    + A의 FOLLOW 전체를 B의 FOLLOW에 추가

<br>

**FOLLOW 예시**

<center><img src="https://github.com/user-attachments/assets/777c4a1f-f4cf-45d3-b0c9-01d6967b3667" width=500></center>

<br><br>

# 💡 LL 조건

LL 조건이란, 문법이 LL 파서로 파싱 가능함을 나타내는 조건으로, 다음과 같다.

- 어떤 nonterminal에 대한 생성 규칙이 두 개 이상일 때, 그 생성 규칙의 FIRST의 교집합이 <br>
  공집합이어야 한다.

    + $ A → α \| β $ &nbsp; 에 대해 &nbsp; $ FIRST(α) ∩ FIRST(β) = ∅ $

<br>

- 만약 한 생성 규칙이 ε를 유도할 수 있다면, FOLLOW와 FIRST도 다른 집합이어야 한다.

    + $ ε ∈ FIRST(α) \; then \; FOLLOW(A) ∩ FIRST(β) = ∅ $

<br>

- 생성 규칙의 FIRST에 공통 원소가 없으면, 각 순간 적용할 생성 규칙이 유일하게 결정된다.



<br><br>

# 👑 문제

<details>
<summary>
1. 다음 문법에서 FIRST, FOLLOW 집합을 구하시오. <br>

<img src="https://github.com/user-attachments/assets/890bfb97-5bba-4724-b296-60a38dfc2859" width=150>

</summary>
<div markdown="1">       

<center><img src="https://github.com/user-attachments/assets/834f5529-e9da-49b0-bc03-b41fa05b9cc1" width=600></center>
<center><img src="https://github.com/user-attachments/assets/2c2d497b-d1c1-42e7-91cb-bfa9ed700aee" width=600></center>

</div>
</details>