---
title: "[C++] 백준 14503 - 로봇 청소기"
excerpt: "BAEKJOON - No-14503"

categories:
  - Baekjoon
tags:
  - [baekjoon]

permalink: /baekjoon/baekjoon_No_14503/

toc: true
toc_sticky: true
use_math: true

date: 2024-09-26
last_modified_at: 2024-09-26
---

# 🔐 백준 14503 - 로봇 청소기

[https://www.acmicpc.net/problem/14503](https://www.acmicpc.net/problem/14503)

<br>

## 🔑 풀이

시뮬레이션 문제를 보았을 때, 중요한 것은 문제의 조건과 입력 등을 정확히 이해하는 것이라고 <br>

생각한다. 우선 방의 크기는 $ N \times M $ 이며, 제일 처음 좌표는 `(0, 0)` 부터 시작한다. <br>

보통 시뮬레이션 문제의 경우 여러 기능들을 각각의 함수로 짜는 것이 가독성이 좋고 편할때가 많았다. <br>

따라서, 이 문제에서 로봇 청소기의 작동 순서를 다음과 같이 정리해보면,

    1. 현재 칸 청소 X -> 현재 칸 청소 (청소한 칸 개수 +1)

    2. 주변 4칸(동서남북)이 모두 깨끗하다면

      2-1. 현재 방향을 유지하고, 후진 가능하다면 후진 -> 1번으로
      2-2. 후진 불가능하다면(벽) 종료

    3. 주변 4칸 중 더러운 칸이 존재한다면 반시계 방향으로 90도 회전

    4. 현재 방향 기준 앞 칸이 더러운 칸이라면 한 칸 전진

    5. 1번으로 돌아감

이제 차근차근 위의 알고리즘대로 코드를 짜면 된다. 우선 주변 4칸을 확인해주는 함수인 <br>

`isDirty()` 함수를 만들어 주었고, 남은 작동은 `operation()` 함수로 구현해주었다. <br>

로봇 청소기의 작동이 멈출때까지, 즉 `2-2`의 상황이 될 때까지 동작해야 하므로, <br>

무한 루프로 감싸주고, 종료 조건을 설정해주었다. 또한, 후진이 가능한지를 확인할 때, <br>

현재 방향의 반대를 구하기 위해 `int backDir = (dir + 2) % 4;` 와 같이 구현하여 <br>

후진한 칸을 확인해주는 방식으로 구현했지만, 이보다 더 간단하게 현재 좌표에서 <br>

현재 방향만큼을 빼주는 것으로 구현할 수도 있다. `(x - dx[dir], y - dy[dir])`

<br>

## 🧩 코드

<script src="https://gist.github.com/jinwoojwa/567bc71c8018efa7584f5e4989f5b879.js"></script>



